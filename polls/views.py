# from django import template
from django.db.models import F
from django.http import HttpRequest, HttpResponse, HttpResponseRedirect
from django.shortcuts import render, get_object_or_404
from django.http import Http404
from django.urls import reverse
from django.views import generic
from django.utils import timezone

# from django.template import Template, loader
from .models import Question, Choice

"""
Each view is responsible for doing one of two things: returning an HttpResponse object containing the content for the requested page, or raising an exception such as Http404. 
The rest is up to you.

"""


"""
Each generic view needs to know what model it will be acting upon.
This is provided using either the model attribute (in this example, model = Question for DetailView and ResultsView) or by defining the get_queryset() method (as shown in IndexView).

By default, the DetailView generic view uses a template called <app name>/<model name>_detail.html.
In our case, it would use the template "polls/question_detail.html". 
The template_name attribute is used to tell Django to use a specific template name instead of the autogenerated default template name.
We also specify the template_name for the results list view –
this ensures that the results view and the detail view have a different appearance when rendered, even though they’re both a DetailView behind the scenes.

Similarly, the ListView generic view uses a default template called <app name>/<model name>_list.html; 
we use template_name to tell ListView to use our existing "polls/index.html" template.

"""


class IndexView(generic.ListView):
    """

    By default, ListView looks for a template named <app_name>/<model_name>_list.html (e.g., polls/question_list.html).
    Here, template_name = "polls/index.html" overrides this default to use your custom template.

    By default, ListView passes the list of objects into the template using the context variable object_list.
    You renamed it to latest_question_list for better readability.

    The get_queryset() method in the IndexView specifies the data (queryset) that the view will retrieve from the database.
    This data is then passed to the template as the context variable latest_question_list, which you explicitly defined in the context_object_name attribute.

    """

    template_name = "polls/index.html"
    context_object_name = "latest_question_list"

    def get_queryset(self):
        """
        Return the last five published questions.(not including those set to be
        published in the future).

        """

        return Question.objects.filter(pub_date__lte=timezone.now()).order_by(
            "-pub_date"
        )[:5]


class DetailView(generic.DetailView):
    model = Question
    template_name = "polls/detail.html"

    def get_queryset(self):
        """
        Excludes any questions that aren't published yet.
        """
        return Question.objects.filter(pub_date__lte=timezone.now())


class ResultsView(generic.DetailView):
    model = Question
    template_name = "polls/results.html"


# returns last 5 most recent questions - first version of index function
# def index(request):
#     latest_question_list: list[Question] = Question.objects.order_by("-pub_date")[:5]
#     template: Template = loader.get_template("polls/index.html")
#     context = {
#         "latest_question_list": latest_question_list,
#     }
#     return HttpResponse(template.render(context, request))


### WE USED GENERIC VIEWS TO SIMPLIFY THIS PORTION
# # shorter way of providing context to template and sending a HttpResponse - handles /polls
# def index(request):
#     latest_question_list = Question.objects.order_by("-pub_date")[:5]
#     context = {"latest_question_list": latest_question_list}
#     return render(request, "polls/index.html", context)
#
#
# # when we click on question - handles /polls/<nos>/
# # def detail(request: HttpRequest, question_id):
# #     try:
# #         question = Question.objects.get(pk=question_id)
# #     except Question.DoesNotExist:
# #         return Http404("Question does not exist")
# #     return render(request, "polls/details.html", {"question": question})
#
#
# # when we click on question - handles /polls/<nos>/
# def detail(request: HttpRequest, question_id):
#     question = get_object_or_404(Question, pk=question_id)
#     return render(request, "polls/detail.html", {"question": question})
#
#
# # when we navigate to a question - handles /polls/<nos>/results
# def results(request, question_id):
#     """
#     redirected here after voting on a question
#
#     """
#     question: Question = get_object_or_404(Question, pk=question_id)
#     return render(request, "polls/results.html", {"question": question})
#


# when we vote on a question - handles /polls/<nos>/vote
def vote(request, question_id):
    """

    Gets the question_id from param and checks if id is there in db, if not returns a 404.
    request.POST["choice"] - gets the choice id from request object on submission of form (inherent property of form to send choices in body of post)
    question.choice_set.get - assumes a foriegn key relation between question and choice models, so we can query choice id based on what we got from post req

    send error message to template if :
        Keyerror - choice not present in postreq, happens when we submit without selecting any choice
        Choice.DoesNotExist - choice id present in post is invalid

    get the votes attr of choice obj and increment by 1. We use F so that it increments the data directly and prevents race condition when multiple users acess the data
    then redirect to results page


    """
    question: Question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice: Choice = question.choice_set.get(pk=request.POST["choice"])
    except (KeyError, Choice.DoesNotExist):
        return render(
            request,
            "polls/detail.html",
            {
                "question": question,
                "error_message": "You did not select a choice.",
            },
        )
    else:
        selected_choice.votes = F("votes") + 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        return HttpResponseRedirect(reverse("polls:results", args=(question.id,)))
